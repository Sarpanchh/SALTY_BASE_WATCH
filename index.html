<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SALTY AR - REGAL VOLUMETRIC</title>
    
    <style>
        body { margin: 0; overflow: hidden; background: #080808; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }
    </style>
</head>
<body>

    <!-- SHADER PROGRAMS -->
    <script type="x-shader/x-vertex" id="vertexShader">
        attribute float size;
        attribute vec3 customColor;
        // type: 0=Text, 1=Watch Body
        attribute float type; 
        
        varying vec3 vColor;
        varying float vAlpha;
        
        uniform float uTime;
        uniform float uJitter; 
        uniform float uExpansion; 

        void main() {
            vec3 pos = position;

            // --- COLOR LOGIC ---
            vec3 initialColor = customColor;
            
            // Text color Morph: Gold -> Soft Purple
            if (type < 0.5) {
                // Target: Soft Salty Lavender (R:0.65, G:0.5, B:0.95)
                vec3 targetColor = vec3(0.65, 0.5, 0.95); 
                float mixFactor = smoothstep(0.1, 0.8, uExpansion);
                vColor = mix(initialColor, targetColor, mixFactor);
            } else {
                vColor = initialColor;
            }

            // Jitter Physics
            if (uJitter > 0.0) {
                 float intensity = (type > 0.5) ? 0.3 : 0.05; 
                 float vib = sin(uTime * 40.0 + position.y * 12.0);
                 pos += vec3(vib * intensity * uJitter);
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            float distSize = 400.0 / -mvPosition.z;
            
            // Sparkle pulse
            float pulse = 1.0;
            if(type > 0.5 && customColor.b > 0.8) {
                 pulse = 1.0 + sin(uTime * 10.0 + position.x) * 0.15;
            }
            
            // --- DYNAMIC SIZING ---
            float finalSize = size;
            
            // Text: Grow slightly to ensure the "Cloud" volume looks solid
            if (type < 0.5) {
                // Expansion Multiplier reduced slightly to prevent blobs, relies on density now
                finalSize = size * (1.0 + uExpansion * 1.5); 
            }
            
            gl_PointSize = finalSize * pulse * distSize;
            vAlpha = smoothstep(90.0, 5.0, -mvPosition.z);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        varying float vAlpha;
        void main() {
            vec4 tex = texture2D(pointTexture, gl_PointCoord);
            gl_FragColor = vec4(vColor, vAlpha) * tex;
            if(gl_FragColor.a < 0.05) discard;
        }
    </script>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- GLOBAL VARIABLES ---
        let spinVelX=0, spinVelY=0, decay=0.96;
        let currentExpansion = 0.0;
        let targetExpansion = 0.0;

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x080808, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.z = 24;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setClearColor(0x000000, 1);
        document.body.appendChild(renderer.domElement);

        // --- FLARE TEXTURE ---
        function createFlare() {
            const s=64; const c=document.createElement('canvas');
            c.width=s; c.height=s;
            const ctx=c.getContext('2d');
            const g=ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.2,'rgba(255,255,255,0.5)'); 
            g.addColorStop(0.5,'rgba(255,255,255,0.1)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,s,s);
            return new THREE.CanvasTexture(c);
        }
        const tex = createFlare();

        // --- TEXT DATA (TRUE VOLUME) ---
        function getTextCoordinates() {
            const W=600, H=200;
            const c=document.createElement('canvas');
            c.width=W; c.height=H;
            const ctx=c.getContext('2d');
            ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
            ctx.font='900 130px Serif'; 
            ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillStyle='#fff'; ctx.fillText('SALTY', W/2, H/2);
            
            const data = ctx.getImageData(0,0,W,H).data;
            const points = [];
            const xyStep = 2; // High density scan
            const zThickness = 3.5; // Thicker letter block
            
            // DENSITY FACTOR: Particles per pixel
            // Previously we looped layers (k=0..3). 
            // Now we create a random volume cloud.
            
            for(let y=0; y<H; y+=xyStep) {
                for(let x=0; x<W; x+=xyStep) {
                    if(data[(y*W+x)*4]>128) {
                        const baseX = (x - W/2) * 0.05;
                        const baseY = ((H-y) - H/2) * 0.05;

                        // Create ~5 particles for every pixel, randomly placed in depth
                        // This prevents "Sheets" or "Slices" appearing from the side.
                        for(let k=0; k<5; k++) {
                             // Random Z within the thickness range
                             const rndZ = (Math.random() - 0.5) * zThickness;
                             
                             // Slight XY noise for "Fuzzy/Solid" feel
                             const nX = (Math.random()-0.5)*0.15;
                             const nY = (Math.random()-0.5)*0.15;

                             points.push({ 
                                 x: baseX + nX, 
                                 y: baseY + nY, 
                                 z: rndZ // Fully random Z
                             });
                        }
                    }
                }
            }
            return points;
        }
        const textPoints = getTextCoordinates();

        // --- WATCH GENERATOR ---
        function createWatchSystem() {
            const textBaseCount = textPoints.length; 
            const debrisCount = 45000; 
            const total = textBaseCount + debrisCount;

            const pos = new Float32Array(total * 3);
            const col = new Float32Array(total * 3);
            const size = new Float32Array(total);
            const type = new Float32Array(total); 
            const meta = new Float32Array(total * 4); 
            const orig = new Float32Array(total * 3);

            const DIAL_W = 4.0; 
            const DIAL_H = 5.8; 
            const BEZEL_W = 0.8; 
            const CHARM_SPACING = 3.6; 
            const START_Y = DIAL_H + 2.0;
            const CHARM_POS = [START_Y, START_Y + CHARM_SPACING, START_Y + CHARM_SPACING*2];
            const WRIST_R_Z = 8.5; 
            const WRIST_Z_OFF = -8.0;

            for(let i=0; i<total; i++) {
                
                let sx, sy, sz;
                let rVal=0, gVal=0, bVal=0;
                let pSize = 0.5;
                const rnd = Math.random();

                if (rnd < 0.35) {
                    // DIAL (OVAL)
                    const theta = Math.random() * Math.PI * 2;
                    const isBezel = Math.random() > 0.5; 
                    let w, h; 
                    if (isBezel) {
                        w = DIAL_W + BEZEL_W * (0.2 + 0.8*Math.random());
                        h = DIAL_H + BEZEL_W * (0.2 + 0.8*Math.random());
                        sx = w * Math.cos(theta);
                        sy = h * Math.sin(theta);
                        const ridge = Math.cos(theta * 40.0);
                        sz = 1.0 + ridge * 0.2; 
                        
                        rVal=1.0; gVal=0.85; bVal=0.3; 
                        pSize = 0.4;
                    } else {
                        const rSq = Math.sqrt(Math.random());
                        w = DIAL_W * rSq;
                        h = DIAL_H * rSq;
                        sx = w * Math.cos(theta);
                        sy = h * Math.sin(theta);
                        sz = 0.8 + (Math.random()*0.1); 
                        
                        rVal=0.96; gVal=0.87; bVal=0.6;
                        pSize = 0.45;
                    }
                } 
                else if (rnd < 0.90) {
                    // STRAP CHARMS
                    const charmIdx = Math.floor(Math.random() * 6);
                    const isTop = charmIdx < 3;
                    const cStep = charmIdx % 3;
                    let cyBase = CHARM_POS[cStep];
                    if (!isTop) cyBase = -cyBase;

                    const tCurve = (cyBase / 20.0) * (Math.PI/2); 
                    const curY = (isTop?1:-1) * 11.0 * Math.sin(Math.abs(tCurve)) * (0.8 + 0.2*cStep); 
                    const curZ = WRIST_Z_OFF + WRIST_R_Z * Math.cos(tCurve*1.2);
                    
                    const R_CHARM = 2.4;  
                    const R_CRYSTAL = 1.2; 
                    const ang = Math.random() * Math.PI * 2;
                    const r = R_CHARM * Math.sqrt(Math.random());
                    const isCrystal = r < R_CRYSTAL;
                    const isGoldRim = !isCrystal;

                    sx = r * Math.cos(ang) + (Math.random()-0.5)*0.1;
                    sy = curY + (r * Math.sin(ang)); 
                    sz = curZ + (Math.random()-0.5)*0.5;

                    if (isGoldRim) {
                        rVal=1.0; gVal=0.82; bVal=0.25; 
                        pSize = 0.4;
                    } else {
                        rVal=0.9; gVal=0.95; bVal=1.0; 
                        pSize = 0.6; 
                        sz += 0.5; 
                    }
                }
                else {
                    // HANDS & INDICES
                    if (Math.random() > 0.4) {
                        const idx = Math.floor(Math.random()*12); 
                        const ang = (idx / 12) * Math.PI * 2;
                        const iX = (DIAL_W * 0.8) * Math.cos(ang);
                        const iY = (DIAL_H * 0.8) * Math.sin(ang);
                        
                        sx = iX + (Math.random()-0.5)*0.2;
                        sy = iY + (Math.random()-0.5)*0.2;
                        sz = 1.2;
                        
                        rVal=0.2; gVal=0.2; bVal=0.2; 
                        pSize = 0.35;
                    } else {
                        // DEEP BLACK/PURPLE HANDS
                        const isMin = Math.random() > 0.5;
                        const angle = isMin ? 5.2 : 0.8;
                        const len = isMin ? DIAL_H * 0.7 : DIAL_H * 0.5;
                        const d = Math.random() * len;
                        sx = d * Math.cos(angle);
                        sy = d * Math.sin(angle);
                        sz = 1.5; 
                        
                        rVal=0.10; gVal=0.0; bVal=0.18; // Almost Black
                    }
                }

                const i3=i*3; const i4=i*4;
                pos.set([sx,sy,sz], i3);
                orig.set([sx,sy,sz], i3);
                
                col.set([rVal, gVal, bVal], i3);
                size[i] = pSize; 

                if (i < textBaseCount) {
                    const t = textPoints[i];
                    type[i] = 0.0; // TEXT
                    meta.set([t.x, t.y, t.z, 0], i4);
                } else {
                    type[i] = 1.0; // DEBRIS
                    const v = new THREE.Vector3(sx,sy,sz).normalize();
                    v.x += (Math.random()-0.5)*0.2; 
                    v.y += (Math.random()-0.5)*0.2;
                    v.z += (Math.random()-0.5)*3.5; 
                    v.normalize();
                    const speed = 1.0 + Math.random()*2.0; 
                    meta.set([v.x, v.y, v.z, speed], i4);
                }
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('customColor', new THREE.BufferAttribute(col, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(size, 1));
            geo.setAttribute('type', new THREE.BufferAttribute(type, 1));

            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    pointTexture: { value: tex },
                    uTime: { value: 0 },
                    uJitter: { value: 0 },
                    uExpansion: { value: 0 } 
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });

            const mesh = new THREE.Points(geo, mat);
            mesh.userData = { orig, meta, types: type }; 
            return mesh;
        }

        const sys = createWatchSystem(); 
        scene.add(sys);

        // --- ANIMATION ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            sys.material.uniforms.uTime.value = time;
            sys.rotation.y += spinVelX;
            sys.rotation.x += spinVelY;
            spinVelX *= decay; 
            spinVelY *= decay;

            currentExpansion += (targetExpansion - currentExpansion) * 0.1;
            sys.material.uniforms.uExpansion.value = currentExpansion;

            let speed = Math.abs(spinVelX) + Math.abs(spinVelY);
            sys.material.uniforms.uJitter.value = (speed * 3.0) + (currentExpansion * 0.2);

            const pos = sys.geometry.attributes.position.array;
            const orig = sys.userData.orig;
            const meta = sys.userData.meta;
            const types = sys.userData.types;
            const count = sys.geometry.attributes.position.count;
            const textProgress = smoothstep(0.1, 0.95, currentExpansion);

            for(let i=0; i<count; i++) {
                const i3=i*3; const i4=i*4;
                const ox=orig[i3], oy=orig[i3+1], oz=orig[i3+2];
                const mx=meta[i4], my=meta[i4+1], mz=meta[i4+2], val=meta[i4+3];

                if (types[i] < 0.5) { 
                    pos[i3]   = ox + (mx - ox) * textProgress;
                    pos[i3+1] = oy + (my - oy) * textProgress;
                    pos[i3+2] = oz + (mz - oz) * textProgress;
                    if (currentExpansion > 0.8) pos[i3+1] += Math.sin(time*2.0 + ox)*0.015;
                } else { 
                    const dist = currentExpansion * val * 90.0; 
                    pos[i3]   = ox + mx * dist;
                    pos[i3+1] = oy + my * dist;
                    pos[i3+2] = oz + mz * dist;
                }
            }
            sys.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function smoothstep(min, max, value) {
            var x = Math.max(0, Math.min(1, (value-min)/(max-min)));
            return x*x*(3 - 2*x);
        }

        animate();

        // --- CONTROLS ---

        let lastX = 0, lastY = 0;
        let isPinching = false;
        let startPinchDist = 0;
        let startPinchExpansion = 0;

        document.addEventListener('wheel', (e) => {
            targetExpansion += e.deltaY * 0.001; 
            targetExpansion = Math.max(0, Math.min(1, targetExpansion));
        });
        document.addEventListener('mousedown', (e) => { lastX=e.clientX; lastY=e.clientY; });
        document.addEventListener('mousemove', (e) => {
            if(e.buttons === 1) { 
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                spinVelX += dx * 0.003;
                spinVelY += dy * 0.003;
                lastX = e.clientX; lastY = e.clientY;
            }
        });

        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isPinching = false;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                isPinching = true;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                startPinchDist = Math.hypot(dx, dy);
                startPinchExpansion = targetExpansion;
            }
        }, {passive: false});

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && !isPinching) {
                const x = e.touches[0].clientX;
                const y = e.touches[0].clientY;
                const dx = x - lastX;
                const dy = y - lastY;
                spinVelX += dx * 0.005; 
                spinVelY += dy * 0.005;
                lastX = x; lastY = y;
            } else if (e.touches.length === 2) {
                e.preventDefault(); 
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.hypot(dx, dy);
                const pixelDelta = dist - startPinchDist;
                let newExp = startPinchExpansion + (pixelDelta / 200.0);
                targetExpansion = Math.max(0, Math.min(1, newExp));
            }
        }, {passive: false});

        document.addEventListener('touchend', () => { isPinching = false; });

        window.onresize = () => { 
            camera.aspect=window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
        };

    </script>
</body>
</html>
